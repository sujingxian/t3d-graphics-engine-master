// Author: David Pentecost
//
// ParticleEmitter.cpp
//
// Particle emitter and controller
// This is a generic particle creator that can be used with any particles that have the
// ParticleBehaviour component.

#include "Math.h"
#include "GameObject.h"
#include "Transform.h"
#include "ParticleEmitter.h"
#include "ParticleBehaviour.h"


namespace T3D
{
	/*
	 * \note This will delete all `Transform`s of the particle system, not the GameObjects themselves. 
	 * \todo When `Transform`s in the scenegraph have shared ownership lifetimes implemented, this may be redundant or as simple as decrementing a refcount
	 */
	ParticleEmitter::~ParticleEmitter()
	{
		for (auto &particle: particles)
		{
			// NOTE: delete gameObjects by deleting their Transform
			delete particle->gameObject->getTransform();		
		}
	}

	/* Particles can be started (emitted) immediately if required
	 * \param particle Particle to add
	 * \param start Start immediately?
	 */
	void ParticleEmitter::addParticle(ParticleBehaviour *particle, bool start)
	{
		particles.push_back(particle);			// add to pool

		if (start) {
			particle->start(this->gameObject->getTransform());	// start relative to emitter
		}
		else {
			particle->stop();	// particle will be added to particlesInactive
		}
	}

	/* 
	 * \note This is intended only to be used by particles to add themselves back into the inactive list for reuse.
	 * \todo This level of abstraction is not necessary.
	 */
	void ParticleEmitter::addInactiveList(ParticleBehaviour *particle)
	{
		particlesInactive.push(particle);
	}

	/* Moves elapsed time to full duration.
	 *
	 * \param clear immediately stop and hide all active particles
	 */
	void ParticleEmitter::stop(bool clear)
	{
		elapsed = duration;			// no more particles will be emitted

		if (clear)					// stop and remove all active particles?
		{
			for (auto &particle: particles)
			{
				if (!particle->isActive()) particle->stop();
			}
		}
	}

	/* 
	 * \param n	Number of particles in the pool to emit.
	*/
	void ParticleEmitter::emit(uint32_t n)
	{
		// Emit required number of particles but only up to what is available
		while (n > 0 && !particlesInactive.empty())
		{
			auto particle = particlesInactive.front();
			particlesInactive.pop();		// remove from inactive list
			particle->start(this->gameObject->getTransform());
			n--;
		}
	}

	void ParticleEmitter::update(float dt)
	{
		float count;
		elapsed += dt;			// total particle system run time

		if (elapsed < duration)
		{
			// work out how many particles should have been emitted for the current elapsed time
			// Includes ramp up, run and wind down as appropriate

			// Get expected particles for initial ramp up
			count = emitRamp(startRate, emitRate, rampUpDuration, elapsed, 0.1f);

			// Plus particles for constant run
			count += emitRamp(emitRate, emitRate, duration - (rampUpDuration+rampDownDuration), elapsed - rampUpDuration, 0.1f);

			// Plus particles for wind down
			count += emitRamp(emitRate, endRate, rampDownDuration, elapsed - (duration - rampDownDuration), 0.1f);

			//std::cout << "expected particles for time " << elapsed << " is " << count << ", particles emitted so far " << emitted << std::endl;

			// count is now the total number of particles (with some random variability) that should have
			// been generated by this time in the particles systems life. 
			count -= emitted;	// minus the number already emitted to give how many we need to emit now

			int e = (int)(count + 0.5f);	// emit rounded up output count
			emit(e);						// emit particles
			emitted += e;					// total emitted so far
		}
	}

	/*! emitRamp
	  * get total expected particle count for a time position along an acceleration ramp
	  * \param start		particles per second at start
	  * \param end			particles per second at end
	  * \param duration		duration of ramp
	  * \param time			time pos (no particles if < 0 or max particles if > duration)
	  * \param				random variability (+/- fraction)
	  */
	float ParticleEmitter::emitRamp(float start, float end, float duration, float time, float variability)
	{
		float accel;		// calculated acceration rate for ramp
		float count;		// expected number of particles produced to the given time

		if (time < 0 || duration <= 0) return 0; // not in ramp or no ramp

		if (time > duration) time = duration;	 // clamp time to max duration of ramp

		accel = (end - start) / duration;		// particles per second per second
		count = start * time + (accel * time * time) / 2.0f;
		count += count * (Math::randRange(0, variability*2) - variability);

		return count;
	}



}
